PROC D_TRIANGLE DISPLOF
;;**********程序功能**********
;;最新的三角程序,抬刀量单独计算,针对X轴向前为正的内螺纹机床
;;***************************
;;DEF REAL D1W,D1V,F1G,F1X,F1Y,G1J,G1X,G1Y
DEF	REAL DR1,DR2,DR3,DR4,DR5,DR6,DR7,DR8
DEF REAL AM,AMX,AMY,HD,OFFSET
DEF REAL WHL_NB,WHR,DF
DEF REAL ANG_CURRENT,ANG_L,ANG_R,R_BOTTOM,ANG_BOTTOM,R_L,R_R
DEF REAL LRHIGHT_ERR,SUML,SUMR,PLWS,PRWS,LDRES_R,RDRES_R
DEF AXIS AX_W,AX_V;水平轴和竖直轴

DEF REAL OFFSET2,DR181,DR270,DK1,ARCAM,WM,VM,WB1,VB1,WD1,VD1,WF1,VF1
DEF REAL WC1,VC1,WE1,VE1,DK2,WG1,VG1
;;;
;读全局变量值
ANG_L=TRI[9]
ANG_R=TRI[10]
R_BOTTOM=TRI[3]
R_L=TRI[11];左圆角调整
R_R=TRI[12];右圆角调整
WHL_NB=DRESSER[22];砂轮宽传递
LDRES_R=DRESSER[31];修左边齿形时的圆角半径传递
RDRES_R=DRESSER[32];修右边齿形时的圆角半径传递
SUML=WHEEL[10];左滚轮与砂轮竖直接触位置
SUMR=WHEEL[11];右滚轮与砂轮竖直接触位置
PLWS=DRESSER[33];修左侧齿形时坐标系水平方向平移距离
PRWS=DRESSER[34];修右侧齿形时坐标系水平方向平移距离
DF=DRESSER[10];当前修整速度传递
LRHIGHT_ERR=SUML-SUMR;计算左右轮接触点高度差
;;;
;水平轴和竖直轴赋值
AX_W=AXNAME(AXIS_HORI);水平轴
AX_V=AXNAME(AXIS_VER);竖直轴

;坐标参数计算
STOPRE
R_BOTTOM=TRI[3]+R_R
WHR=RDRES_R;滚轮半径改为右滚轮半径
ANG_CURRENT=ANG_R
ANG_BOTTOM=ANG_L+ANG_R
AM=WHR/SIN(ANG_BOTTOM/2)
AMX=AM*SIN(ANG_L/2-ANG_R/2)
AMY=-WHR+AM*COS(ANG_L/2-ANG_R/2)

BEGIN: DR1=WHR*COS(ANG_CURRENT)+TRI[0]*TAN(ANG_CURRENT)
DR2=-WHR-TRI[0]+WHR*SIN(ANG_CURRENT)
;D1点的计算左右两侧用同一套公式
HD=(WHL_NB-TRI[0]*(TAN(ANG_L)+TAN(ANG_R)))/2
OFFSET=HD+TRI[0]*TAN(ANG_L)-WHL_NB/2

DR3=WHL_NB/2+OFFSET-DR1+1+WHR*SIN(TRI[15])
DR4=DR1+DR3
DR5=DR2-DR3*TAN(TRI[15])

DR6=WHL_NB/2-OFFSET-DR1+1+WHR*SIN(TRI[15])
DR7=DR1+DR6
END: DR8=DR2-DR6*TAN(TRI[15])
;;以上为尖三角的数据计算

;;带圆弧三角左部分
WHR=LDRES_R
R_BOTTOM=TRI[3]+R_L
ARCAM=R_BOTTOM/SIN(ANG_BOTTOM/2)
WM=-ARCAM*SIN((ANG_L-ANG_R)/2)
VM=-(WHR+R_BOTTOM)+ARCAM*COS((ANG_L-ANG_R)/2)
DR181=VM-(-WHR-TRI[0])
WB1=(WHR+R_BOTTOM)*COS(ANG_L)
VB1=(-1+SIN(ANG_L))*(WHR+R_BOTTOM)
WD1=WM+DR181*TAN(ANG_L)+WHR*COS(ANG_L)
VD1=VM-DR181+WHR*SIN(ANG_L)
DR270=(WHL_NB-DR181*(TAN(ANG_L)+TAN(ANG_R)))/2
OFFSET2=DR270+DR181*TAN(ANG_L)-WHL_NB/2+WM
DK1=WHL_NB/2+OFFSET2-WD1+1+WHR*SIN(TRI[15])
WF1=WD1+DK1
VF1=VD1-DK1*TAN(TRI[15])

;;带圆弧三角右部分
WHR=RDRES_R
R_BOTTOM=TRI[3]+R_R
ARCAM=R_BOTTOM/SIN(ANG_BOTTOM/2)
WM=-ARCAM*SIN((ANG_L-ANG_R)/2)
VM=-(WHR+R_BOTTOM)+ARCAM*COS((ANG_L-ANG_R)/2)
WC1=-(WHR+R_BOTTOM)*COS(ANG_R)
VC1=(-1+SIN(ANG_R))*(WHR+R_BOTTOM)
WE1=-(DR181*TAN(ANG_R)+WHR*COS(ANG_R)-WM)
VE1=VM-DR181+WHR*SIN(ANG_R)
DK2=WHL_NB/2-OFFSET2+WE1+1+WHR*SIN(TRI[15])
WG1=WE1-DK2
VG1=VE1-DK2*TAN(TRI[15])

STOPRE
;右半边
R_BOTTOM=TRI[3]+R_R
WHR=RDRES_R;滚轮半径改为右滚轮半径
ANG_CURRENT=ANG_R
REPEAT BEGIN END
TRANS AX[AX_W]=PRWS-OFFSET2 AX[AX_V]=SUML+LRHIGHT_ERR
IF R_BOTTOM<>0
	G90 G01 AX[AX_W]=WHL_NB/2 
	G90 G01 AX[AX_V]=0
	G90 G01 AX[AX_W]=0 F=DF
	G90 G03 AX[AX_W]=WC1 AX[AX_V]=-VC1 CR=WHR+R_BOTTOM
	G01 AX[AX_W]=WE1 AX[AX_V]=-VE1
	G01 AX[AX_W]=WG1 AX[AX_V]=-VG1
	G01 AX[AX_V]=0 F=500
	G01 AX[AX_W]=-WHL_NB/2
ELSE
	G90 G01 AX[AX_V]=-AMY F=500;到第一条直线起点
	G90 G01 AX[AX_W]=-AMX
	G90 G01 AX[AX_W]=-DR1 AX[AX_V]=-DR2 F=DF
	G90 G01 AX[AX_W]=-DR7 AX[AX_V]=-DR8
	G90 G01 AX[AX_V]=-AMY F=500
	G90 G01 AX[AX_W]=-WHL_NB/2-WHR
ENDIF

STOPRE
;左半边
R_BOTTOM=TRI[3]+R_L
WHR=LDRES_R;滚轮半径改为左滚轮半径
ANG_CURRENT=ANG_L
REPEAT BEGIN END
TRANS AX[AX_W]=PLWS-OFFSET2 AX[AX_V]=SUML
IF R_BOTTOM<>0
	G90 G01 AX[AX_W]=-WHL_NB/2 
	G90 G01 AX[AX_V]=0
	G90 G01 AX[AX_W]=0 F=DF
	G90 G02 AX[AX_W]=WB1 AX[AX_V]=-VB1 CR=WHR+R_BOTTOM
	G01 AX[AX_W]=WD1 AX[AX_V]=-VD1
	G01 AX[AX_W]=WF1 AX[AX_V]=-VF1
	G01 AX[AX_V]=0 F=500
	G01 AX[AX_W]=WHL_NB/2 
ELSE
	G90 G01 AX[AX_V]=-AMY F=500;到第一条直线起点
	G90 G01 AX[AX_W]=-AMX
	G90 G01 AX[AX_W]=DR1 AX[AX_V]=-DR2 F=DF
	G90 G01 AX[AX_W]=DR4 AX[AX_V]=-DR5
	G01 G90 AX[AX_V]=-AMY F=1200
ENDIF

TRANS
STOPRE
RET

